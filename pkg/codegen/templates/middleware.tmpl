// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
	Middlewares map[string]func(http.Handler) http.Handler
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

{{range .}}{{$opid := .OperationID}}

// {{$opid}} operation middleware
func (siw *ServerInterfaceWrapper) {{$opid}}(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	{{range .PathParams}}// ------------- Path parameter "{{.ParamName}}" -------------
	var {{$varName := .GoVariableName}}{{$varName}} {{.TypeDef}}

	{{if .IsPassThrough}}
	{{$varName}} = chi.URLParam(r, "{{.ParamName}}")
	{{end}}
	{{if .IsJSON}}
	if err := json.Unmarshal([]byte(chi.URLParam(r, "{{.ParamName}}")), &{{$varName}}); err != nil {
		err = fmt.Errorf("error unmarshaling parameter '{{.ParamName}}' as JSON: %w", err)
		siw.ErrorHandlerFunc(w, r, &UnmarshalingParamError{err, "{{.ParamName}}"})
		return
	}
	{{end}}
	{{if .IsStyled}}
	if err := runtime.BindStyledParameter("{{.Style}}",{{.Explode}}, "{{.ParamName}}", chi.URLParam(r, "{{.ParamName}}"), &{{$varName}}); err != nil {
		err = fmt.Errorf("invalid format for parameter {{.ParamName}}: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err, "{{.ParamName}}"})
		return
	}
	{{end}}

	{{end}}

{{range .SecurityDefinitions}}
	ctx = context.WithValue(ctx, {{.ProviderName | ucFirst}}Scopes, {{toStringArray .Scopes}})
{{end}}

	{{if .RequiresParamObject}}
		// Parameter object where we will unmarshal all parameters from the context
		var params {{.OperationID}}Params

		{{range $paramIdx, $param := .QueryParams}}// ------------- {{if .Required}}Required{{else}}Optional{{end}} query parameter "{{.ParamName}}" -------------
			{{if .IsStyled}}
			if err := runtime.BindQueryParameter("{{.Style}}", {{.Explode}}, {{.Required}}, "{{.ParamName}}", r.URL.Query(), &params.{{.GoName}}); err != nil {
				err = fmt.Errorf("invalid format for parameter {{.ParamName}}: %w", err)
				siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err, "{{.ParamName}}"})
				return
			}
			{{else}}
			if paramValue := r.URL.Query().Get("{{.ParamName}}"); paramValue != "" {
			{{if .IsPassThrough}}
				params.{{.GoName}} = {{if .IndirectOptional}}{{if not .Required}}&{{end}}{{end}}paramValue
			{{end}}
			{{if .IsJSON}}
				var value {{.TypeDef}}
				if err := json.Unmarshal([]byte(paramValue), &value); err != nil {
					err = fmt.Errorf("error unmarshaling parameter '{{.ParamName}}' as JSON: %w", err)
					siw.ErrorHandlerFunc(w, r, &UnmarshalingParamError{err, "{{.ParamName}}"})
					return
				}
				params.{{.GoName}} = {{if .IndirectOptional}}{{if not .Required}}&{{end}}{{end}}value
			{{end}}
			}{{if .Required}} else {
					err := fmt.Errorf("query argument {{.ParamName}} is required, but not found")
					siw.ErrorHandlerFunc(w, r, &RequiredParamError{err, "{{.ParamName}}"})
					return
			}{{end}}
			{{end}}
	{{end}}

		{{if .HeaderParams}}
			headers := r.Header

			{{range .HeaderParams}}// ------------- {{if .Required}}Required{{else}}Optional{{end}} header parameter "{{.ParamName}}" -------------
				if valueList, found := headers[http.CanonicalHeaderKey("{{.ParamName}}")]; found {
					var {{.GoName}} {{.TypeDef}}
					n := len(valueList)
					if n != 1 {
						err := fmt.Errorf("expected one value for {{.ParamName}}, got %d", n)
						siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{err, "{{.ParamName}}"})
						return
					}

				{{if .IsPassThrough}}
					params.{{.GoName}} = {{if .IndirectOptional}}{{if not .Required}}&{{end}}{{end}}valueList[0]
				{{end}}

				{{if .IsJSON}}
					if err := json.Unmarshal([]byte(valueList[0]), &{{.GoName}}); err != nil {
						err = fmt.Errorf("error unmarshaling parameter '{{.ParamName}}' as JSON: %w", err)
						siw.ErrorHandlerFunc(w, r, &UnmarshalingParamError{err, "{{.ParamName}}"})
						return
					}
				{{end}}

				{{if .IsStyled}}
					if err := runtime.BindStyledParameterWithLocation("{{.Style}}",{{.Explode}}, "{{.ParamName}}", runtime.ParamLocationHeader, valueList[0], &{{.GoName}}); err != nil {
						err = fmt.Errorf("invalid format for parameter {{.ParamName}}: %w", err)
						siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err, "{{.ParamName}}"})
						return
					}
				{{end}}

					params.{{.GoName}} = {{if .IndirectOptional}}{{if not .Required}}&{{end}}{{end}}{{.GoName}}

				} {{if .Required}}else {
						err := fmt.Errorf("header parameter {{.ParamName}} is required, but not found")
						siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{err, "{{.ParamName}}"})
						return
				}{{end}}

			{{end}}
		{{end}}

		{{range .CookieParams}}
			if cookie, err := r.Cookie("{{.ParamName}}"); err == nil {

			{{- if .IsPassThrough}}
				params.{{.GoName}} = {{if .IndirectOptional}}{{if not .Required}}&{{end}}{{end}}cookie.Value
			{{end}}

			{{- if .IsJSON}}
				var value {{.TypeDef}}
				var decoded string
				decoded, err := url.QueryUnescape(cookie.Value)
				if err != nil {
					err = fmt.Errorf("error unescaping cookie parameter '{{.ParamName}}'")
					siw.ErrorHandlerFunc(w, r, &UnescapedCookieParamError{err})
					return
				}

				err = json.Unmarshal([]byte(decoded), &value)
				if err != nil {
					err = fmt.Errorf("error unmarshaling parameter '{{.ParamName}}' as JSON: %w", err)
					siw.ErrorHandlerFunc(w, r, &UnmarshalingParamError{err, "{{.ParamName}}"})
					return
				}

				params.{{.GoName}} = {{if .IndirectOptional}}{{if not .Required}}&{{end}}{{end}}value
			{{end}}

			{{- if .IsStyled}}
				var value {{.TypeDef}}
				if err := runtime.BindStyledParameter("simple",{{.Explode}}, "{{.ParamName}}", cookie.Value, &value); err != nil {
					err = fmt.Errorf("invalid format for parameter {{.ParamName}}: %w", err)
					siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err, "{{.ParamName}}"})
					return
				}
				params.{{.GoName}} = {{if .IndirectOptional}}{{if not .Required}}&{{end}}{{end}}value
			{{end}}

			}

			{{- if .Required}} else {
				err := fmt.Errorf("query argument {{.ParamName}} is required, but not found")
				siw.ErrorHandlerFunc(w, r, &RequiredParamError{err, "{{.ParamName}}"})
				return
			}
			{{- end}}
		{{end}}
	{{end}}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.{{.OperationID}}(w, r{{genParamNames .PathParams}}{{if .RequiresParamObject}}, params{{end}})
	})

	{{ with .Middlewares -}}
	// Operation specific middleware
	{{- range . }}
	{{ $tag := printf "%q" . -}}
	handler = siw.Middlewares[{{$tag}}](handler).ServeHTTP
	{{- end }}
	{{- end }}

	handler(w, r.WithContext(ctx))
}
{{end}}

type UnescapedCookieParamError struct {
	error
}

type UnmarshalingParamError struct {
	error
	paramName string
}

type RequiredParamError struct {
	error
	paramName string
}

type RequiredHeaderError struct {
	error
	paramName string
}

type InvalidParamFormatError struct {
	error
	paramName string
}

type TooManyValuesForParamError struct {
	error
	paramName string
}

// ParameterName is an interface that is implemented by error types that are
// relevant to a specific parameter.
type ParameterError interface {
	error
	// ParamName is the name of the parameter that the error is referring to.
	ParamName() string
}

func (err UnmarshalingParamError) ParamName() string     { return err.paramName }
func (err RequiredParamError) ParamName() string         { return err.paramName }
func (err RequiredHeaderError) ParamName() string        { return err.paramName }
func (err InvalidParamFormatError) ParamName() string    { return err.paramName }
func (err TooManyValuesForParamError) ParamName() string { return err.paramName }
